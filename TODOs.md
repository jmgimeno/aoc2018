# TODOS

* day5
  * use collections.deque instead of lists

* day6
  * use numpy?

* day9
  * implement circular list
  * use method rotation in collections.deque

* day10
  * use numpy
  * use simpler function to minimize

* day11
  * optimize brute search

* day12
  * fix problem with periods longer than one by computing the state you'll get into when entering the last period fragment at the end

* day13
  * use also functions to model orientations (e.g, an orient function gives the position to next position in this orientation)
  * use translation and transformation matrices for operating on the positions

* day14:
  * improve the C++ solution to a more idiomatic code

* day15:
  * change representation of problem to one similar to the diagrans
    * Unit(x,y,type_,hit_points)
    * array of units
    * matrix of characters: # wall . space n Ã­ndex of unit
    
* day17
  * lots of refactoring are needed
  
* day19
  * implement a real factorization algorithm
  
* day20
  * Preprocess parentheses and create an estructure of 
  (open_pos, close_pos, [bar_pos]) and then use walkers
  
